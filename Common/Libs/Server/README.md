# **Boost.Asio 기반 멀티스레드 게임 서버 라이브러리**  
### **(C++20 기반, Cross-Platform 설계)**  

> **최초 작성**: 2025-03-08 (BeomJin Na)  
> **마지막 업데이트**: 2025-03-08 (BeomJin Na)

이 문서는 **멀티스레드 환경에서 안전하고 효율적으로 동작하는 게임 서버**를 구현하고자 할 때 사용할 수 있는 **Boost.Asio 기반의 서버 라이브러리**에 대한 **구조 및 사용 안내서**입니다.

게임 서버뿐 아니라 채팅 서버나 실시간 서비스를 위한 서버를 작성할 때에도 널리 활용될 수 있도록 **범용적인 구조**를 가지고 있습니다.

---

## 1. 서버 라이브러리의 개요와 특징

이 서버 라이브러리는 단순히 TCP 소켓 통신을 처리하는 것을 넘어, **“공간(Hub)과 사용자(User)” 개념**을 활용해 서버 내부 로직을 직관적으로 작성할 수 있도록 합니다.

### **주요 설계 목표**

- **멀티스레딩과 비동기 처리**
  - Boost.Asio와 C++20의 멀티스레딩 기능을 활용하여 다수의 클라이언트를 효율적으로 처리합니다.
  - 각 기능이 비동기적이고 병렬적으로 처리되도록 구현되었습니다.

- **Mutex 최소화 (Lock-free 스타일)**
  - mutex의 직접 사용을 최소화하여 성능 병목을 줄이고 로직을 간단하게 유지합니다.
  - Boost.Asio의 **strand** 개념을 적극적으로 사용하여 동시성을 효율적으로 관리합니다.

- **Hub-User 공간 모델**
  - 사용자는 **동시에 단 하나의 Hub에만 소속**될 수 있습니다.
  - 현실의 **"행사장(Hub)-참가자(User)" 모델**을 서버 구조로 그대로 옮긴 개념이며, 클라이언트 이동과 상태 관리가 직관적입니다.

- **명령어 기반 프로토콜 (ICommand 기반)**
  - 클라이언트와 서버 간의 통신은 전부 **ICommand**라는 명령어 객체로 통합되어 관리됩니다.
  - 명령어는 직렬화(Serialize)와 역직렬화(Deserialize)를 통해 간편하게 네트워크 통신으로 변환됩니다.

---

## 2. 라이브러리의 핵심 구조

### **Hub-User 모델의 이해**

서버는 아래의 계층 구조를 가집니다:

```
Server
  └─ TicketBooth (Hub 상속)
       └─ Lobby (Hub 상속)
            └─ GameRoom (Hub 상속, 선택적)
```

- **TicketBooth**는 서버의 입구 역할을 하며, 새로운 접속자를 받아들여 최초의 사용자(User)를 생성하고 관리합니다.
- **Lobby**는 접속한 사용자들이 머무르는 대기 공간으로, 채팅이나 게임방 생성을 관리합니다.
- **GameRoom**은 실제 게임 로직이 돌아가는 공간으로, 사용자들이 게임을 플레이하기 위해 이동할 수 있습니다.

사용자는 항상 특정 Hub에 소속되며, Hub 내부에서는 모든 로직이 **단일 스레드처럼 동작하도록** strand로 보호되어 있습니다. 이를 통해 mutex 없이도 thread-safe한 로직 작성이 가능합니다.

---

### **스레드 클래스와 데이터 클래스의 구분**

이 서버 구조의 핵심 설계 개념은 클래스들을 **스레드를 관리하는 클래스**와 **데이터만 관리하는 클래스**로 구분하여 동기화 문제를 최소화한 것입니다.

- **스레드 클래스** (`Hub`, `Session`)
  - 자체 strand(실행 큐)를 보유하며, 모든 작업은 strand를 통해 직렬로 실행됩니다.
  - 클래스 내부 로직은 단일 스레드 프로그램처럼 작성 가능하며, data race를 신경쓰지 않아도 됩니다.

- **데이터 클래스** (`User`, `Server`)
  - 자체 스레드가 없으며, 여러 스레드에서 접근 가능한 데이터를 원자적(atomic) 또는 안전한 방법으로 관리합니다.
  - 데이터 클래스는 외부에서 접근 가능한 메서드를 모두 thread-safe하게 구현하여 동시 접근을 허용합니다.

이러한 구조 덕분에, 동시성 문제가 발생 가능한 부분이 명확히 구분되어 있으며, 개발자는 간단하고 직관적인 방식으로 스레드 안정성을 보장할 수 있습니다.

---

## 3. 클래스 간 구조적 관계 (다이어그램)

아래의 다이어그램은 각 클래스 간의 관계 및 데이터 흐름을 나타낸 것입니다.

TicketBooth, Lobby, GameRoom은 모두 Hub를 상속받는 클래스입니다.

```
+---------------+        소유        +-------------------+
|    Server     |------------------->|   TicketBooth     |
+---------------+                    +---------+---------+
                                               |
                                      +--------v--------+
                                      |      Lobby      |
                                      +--------+--------+
                                               |
                                      +--------v--------+
                                      |    GameRoom     |
                                      +-----------------+

             (소유)
 Hub -----------------------> User
                                |
                                v
                             Session
                                |
                                v
                         TCP (클라이언트 연결)
```

- Server는 TicketBooth를 소유하며, TicketBooth는 Lobby를, Lobby는 GameRoom을 관리합니다.
- User는 오직 한 개의 Hub에만 소속될 수 있으며, Hub가 User를 관리합니다.
- User는 Session을 소유하며, Session은 클라이언트와 실제 TCP 연결을 관리합니다.

---

## 4. 실제 서버 작동 예시 흐름

아래는 실제 서버가 동작하는 과정을 설명하는 예제 시나리오입니다.

```plaintext
1. 서버 시작(Server 클래스)
   └─ TicketBooth 생성 후 접속 대기

2. 클라이언트 접속
   └─ TicketBooth가 User와 Session 생성

3. 클라이언트 로그인 요청(ICommand: C2S_RequestLogin)
   └─ TicketBooth가 로그인 처리 후 사용자 이름 설정
   └─ 성공 시 Lobby로 사용자를 이동시킴

4. 로비에서 사용자 활동
   └─ 사용자는 채팅, 게임방 생성 등의 ICommand를 전송
   └─ Lobby가 이를 처리하여 모든 사용자에게 브로드캐스트

5. 게임방 이동 (선택적)
   └─ 사용자가 방을 만들거나 참여 요청하면, Lobby가 사용자 이동 처리
   └─ GameRoom에서 게임 로직 실행

6. 접속 종료
   └─ 사용자가 연결을 종료하면, User는 자동으로 Hub에서 제거되고 Session 정리
```

모든 단계는 ICommand 객체로 비동기적이고 thread-safe하게 처리됩니다.

---

## 5. 확장 포인트 및 고려사항(TODO)

이 라이브러리는 다음과 같은 다양한 방식으로 확장 가능합니다.

- **게임 로직 확장**: GameRoom 클래스에서 실시간 게임 로직을 추가
- **인증 및 보안**: 로그인 시 인증 절차나 DB 연동 기능 추가
- **다중 로비 및 채널**: 다수의 Lobby 생성으로 사용자 분산 관리